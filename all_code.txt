=== src/middleware/rateLimiter.ts ===
// src/middleware/rateLimiter.ts
import rateLimit from "express-rate-limit";
import type { RequestHandler } from "express";

export const authRateLimiter: RequestHandler = rateLimit({
    windowMs: 5 * 60 * 1000,
    max: 5,
    handler: (req, res , next) => {
        return res.status(429).json({
            success: false,
            message: "Too many authentication attempts, please try again later",
        });
    }
});

export const apiRateLimiter: RequestHandler = rateLimit({
    windowMs: 1 * 60 * 1000,
    max: 200,
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res , next) => {
        return res.status(429).json({
            success: false,
            message: "Too many requests, please try again later",
        });
    },
});
=== src/middleware/auth.ts ===
import dotenv from 'dotenv';
dotenv.config();

if (!process.env.JWT_SECRET) {
    throw new Error("FATAL ERROR: JWT_SECRET is not defined.");
}

import jwt from "jsonwebtoken";
import type { Request, Response, NextFunction } from "express";

declare module "express-serve-static-core" {
    interface Request {
        user?: JwtPayload;
    }
}

export interface JwtPayload {
    googleId: string;
    email: string;
    firstName: string;
    lastName: string;
    picture: string;
    exp?: number;
    iat?: number;
}

export function authMiddleware(req: Request, res: Response, next: NextFunction) {
    const authHeader = req.headers["authorization"];
    const token = authHeader && authHeader.split(" ")[1]; // ÿ™ŸàŸÇÿπ "Bearer <token>"

    if (!token) {
        return res.status(401).json({
            success: false,
            message: "Token required"
        });
    }

    try {
        const payload = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;
        req.user = payload;
        next();
    } catch (err: any) {
        if (err.name === "TokenExpiredError") {
            return res.status(401).json({ success: false, message: "Token expired" });
        }
        if (err.name === "JsonWebTokenError") {
            return res.status(403).json({ success: false, message: "Invalid token" });
        }
        return res.status(500).json({ success: false, message: "Token verification failed" });
    }
}=== src/database/connection.ts ===
import mongoose from 'mongoose';
import dotenv from 'dotenv';

if (process.env.NODE_ENV === 'test') {
    dotenv.config({ quiet: true });
} else {
    dotenv.config();
}

mongoose.set('strictQuery', true);
mongoose.set('sanitizeFilter', true);

let uri = process.env.MONGODB_URI;
if (!uri) {
    if (process.env.NODE_ENV === 'production') {
        console.error('‚ùå MONGODB_URI is required in production');
        process.exit(1);
    }
    uri = 'mongodb://localhost:27017/couponati';
}

export const connectDB = async (): Promise<void> => {
    try {
        await mongoose.connect(uri, {
            retryWrites: true,
            w: 'majority',
            serverSelectionTimeoutMS: 10000
        });
        console.log('üü¢ Connected to the database successfully');
    } catch (error) {
        console.error('üî¥ DB connection failed:', error);
        process.exit(1);
    }
};=== src/models/User.model.ts ===
import { Schema, model, Document, Types } from 'mongoose';

export interface User extends Document {
    _id: Types.ObjectId;
    googleId: string;
    email?: string;
    phone?: string;
    firstName?: string;
    lastName?: string;
    age?: number;
    picture?: String;
    gender?: 'male' | 'female' | 'other';
    favourites: Types.ObjectId[];
    role: 'user' | 'admin';
}

const userSchema = new Schema<User>(
    {
        googleId: {
            type: String,
            required: [true, 'User must have a Google ID'],
            unique: true,
            index: true
        },
        email: {
            type: String,
            unique: true,
            sparse: true,
            lowercase: true,
            trim: true,
            match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email'],
        },
        phone: {
            type: String,
            sparse: true,
            unique: true,
            match: [/^[+]?[1-9][\d\s\-\(\)]{7,15}$/, 'Please enter a valid phone number'],
        },
        firstName: {
            type: String,
            trim: true,
            minlength: [1, 'First name must be at least 1 character long'],
            maxlength: [30, 'First name cannot exceed 30 characters']
        },
        lastName: {
            type: String,
            trim: true,
            minlength: [1, 'Last name must be at least 1 character long'],
            maxlength: [30, 'Last name cannot exceed 30 characters']
        },
        picture: {
            type: String,
        },
        age: {
            type: Number,
            min: [13, 'Age must be at least 13 years old'],
            max: [120, 'Age cannot exceed 120 years']
        },
        gender: {
            type: String,
            enum: {
                values: ['male', 'female', 'other'],
                message: 'Gender must be male, female, or other'
            }
        },
        favourites: [{ type: Schema.Types.ObjectId, ref: 'Store' }],
        role: {
            type: String,
            enum: {
                values: ['user', 'admin'],
                message: 'Role must be user or admin'
            },
            default: 'user',
        },
    },
    { timestamps: true }
);

export const User = model<User>('User', userSchema);=== src/models/Store.model.ts ===
import { Schema, model, Document, Types } from 'mongoose';

export interface Store extends Document {
    _id: Types.ObjectId;
    name: string;
    icon?: string;
    banner?: string;
    description?: string;
    link?: string;
    active: boolean;
    order: number;
    category: Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

const storeSchema = new Schema<Store>(
    {
        name: { type: String, required: true, trim: true },
        icon: { type: String, trim: true, default: null },
        banner: { type: String, trim: true, default: null },
        description: { type: String, trim: true, default: '' },
        link: { type: String, trim: true, default: null },
        active: { type: Boolean, default: true },
        order: { type: Number, default: 0 },
        category: { type: Schema.Types.ObjectId, ref: 'Category', required: true },
    },
    { timestamps: true }
);

// Pre-save middleware ŸÖÿ≠ÿ≥ŸÜ ŸÑÿ™ÿ¨ŸÜÿ® ÿßŸÑŸÖÿ¥ÿßŸÉŸÑ
storeSchema.pre<Store>('save', async function (next) {
    if (this.isNew && (this.order === undefined || this.order === 0)) {
        try {
            // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ this.constructor ÿ®ÿØŸÑÿßŸã ŸÖŸÜ Store ŸÑÿ™ÿ¨ŸÜÿ® ÿßŸÑŸÖÿ¥ÿßŸÉŸÑ
            const StoreModel = this.constructor as any;
            const lastStore = await StoreModel.findOne({}, { order: 1 })
                .sort({ order: -1 })
                .lean()
                .exec();

            this.order = lastStore ? lastStore.order + 1 : 1;
            next();
        } catch (err) {
            next(err as Error);
        }
    } else {
        next();
    }
});

storeSchema.virtual('coupons', {
    ref: 'Coupon',
    localField: '_id',
    foreignField: 'store',
});

storeSchema.set('toJSON', { virtuals: true });
storeSchema.set('toObject', { virtuals: true });

// ÿ•ÿ∂ÿßŸÅÿ© index ŸÖÿ±ŸÉÿ® ŸÑŸÑÿ£ÿØÿßÿ° ÿßŸÑÿ£ŸÅÿ∂ŸÑ
storeSchema.index({ active: 1, order: 1 });
storeSchema.index({ category: 1, active: 1 });
storeSchema.index({ name: 1, category: 1 }, { unique: true }); // ŸÖŸÜÿπ ÿßŸÑÿ™ŸÉÿ±ÿßÿ±

export const Store = model<Store>('Store', storeSchema);=== src/models/Category.model.ts ===
import { Schema, model, Document, Types } from 'mongoose';

export interface Category extends Document {
    _id: Types.ObjectId;
    name: string;
    active: boolean;
    order: number;
    createdAt: Date;
    updatedAt: Date;
}

const categorySchema = new Schema<Category>(
    {
        name: {
            type: String,
            required: true,
            trim: true,
            unique: true
        },
        active: { type: Boolean, default: true },
        order: { type: Number, default: 0 },
    },
    { timestamps: true }
);

// Pre-save middleware to set order automatically for new categories
categorySchema.pre<Category>('save', async function (next) {
    if (this.isNew && (this.order === undefined || this.order === 0)) {
        try {
            // Using this.constructor to avoid issues
            const CategoryModel = this.constructor as any;
            const lastCategory = await CategoryModel.findOne({}, { order: 1 })
                .sort({ order: -1 })
                .lean()
                .exec();

            this.order = lastCategory ? lastCategory.order + 1 : 1;
            next();
        } catch (err) {
            next(err as Error);
        }
    } else {
        next();
    }
});

// Add indexes for better performance
categorySchema.index({ active: 1, order: 1 });

export const Category = model<Category>('Category', categorySchema);=== src/models/Banner.model.ts ===
import { Schema, model, Document, Types } from 'mongoose';

export interface Banner extends Document {
  _id: Types.ObjectId; 
  name: string;
  image: string;
  link?: string;
  active: boolean;
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

const bannerSchema = new Schema<Banner>(
  {

    name: {
      type: String,
      required: true,
      trim: true,
    },
    image: {
      type: String,
      required: true,
      trim: true,
    },
    link: {
      type: String,
      trim: true,
      default: null,
    },
    active: {
      type: Boolean,
      default: true,
    },
    order: {
      type: Number,
      default: 0,
    },
  },
  {
    timestamps: true,
  }
);

export const Banner = model<Banner>('Banner', bannerSchema);
=== src/models/Coupon.model.ts ===
import { Schema, model, Document, Types } from 'mongoose';

export interface Coupon extends Document {
    _id: Types.ObjectId;
    code: string;
    discount: number;
    usedCount?: number;
    description?: string;
    expiryDate?: Date;
    active: boolean;
    store: Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

const couponSchema = new Schema<Coupon>(
    {
        code: { type: String, required: true, trim: true },
        discount: { type: Number, required: true, min: 0, max: 100 },
        usedCount: { type: Number, default: 0 },
        description: { type: String, trim: true, default: '' },
        expiryDate: { type: Date },
        active: { type: Boolean, default: true },
        store: { type: Schema.Types.ObjectId, ref: 'Store', required: true },
    },
    { timestamps: true }
);

export const Coupon = model<Coupon>('Coupon', couponSchema);
=== src/controllers/auth.controller.ts ===
import dotenv from 'dotenv';
dotenv.config();

import type { Request, Response } from "express";
import { verifyGoogleToken } from '../services/googleService.js';
import jwt from "jsonwebtoken";
import { User } from '../models/User.model.js';

export const googleLogin = async (req: Request, res: Response) => {
    const { idToken } = req.body
    if (!idToken) return res.status(400).json({ error: 'No idToken provided' });

    try {
        const payload = await verifyGoogleToken(idToken);
        if (!payload || !payload.sub) {
            return res.status(401).json({
                success: false,
                message: 'Invalid token payload'
            });
        }

        // console.log(payload)
        const googleId = payload.sub;
        const email = payload.email;
        const firstName = payload.given_name;
        const lastName = payload.family_name;
        const picture = payload.picture;
        if (!email) return res.status(400).json({ success: false, message: "Email not provided by Google" });

        // findOrCreate
        const user = await User.findOneAndUpdate(
            { googleId },
            {
                googleId,
                email,
                firstName,
                lastName,
                picture
            },
            { new: true, upsert: true }
        ).populate('favourites');


        const token = jwt.sign(
            { googleId, email, firstName, lastName, picture },
            process.env.JWT_SECRET as string,
            { expiresIn: "1000d" }
        );


        console.log(user)

        return res.status(200).json({
            success: true,
            message: "google logged in successfuly",
            data: {
                user: {
                    googleId: user.googleId,
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName,
                    picture: user.picture,
                    favourites: user.favourites
                },
                token
            }
        })
    } catch (err) {
        console.error('googleLogin error:', err);
        return res.status(500).json({
            success: false,
            message: 'Server error'
        });
    }
};

// TODO:
export const verifyToken = async (req: Request, res: Response) => {
    const tokenUser = req.user;
    if (!tokenUser) {
        return res.status(401).json({
            success: false,
            message: "Unauthorized: user payload required"
        })
    }
    try {
        const dbUser = await User.findOne({ googleId: tokenUser.googleId });
        if (!dbUser) {
            return res.status(404).json({
                success: false,
                message: "User not found in database"
            });
        }

        return res.status(200).json({
            success: true,
            message: "User retrieved successfully",
            data: {
                user: dbUser
            }
        });
    } catch (err) {
        console.error('verifyToken error:', err);
        return res.status(500).json({ success: false, message: "Database error" });
    }
}=== src/controllers/admin/store.controller.ts ===
import type { Request, Response } from "express";
import { Store } from "../../models/Store.model.js";
import { Category } from "../../models/Category.model.js";
import { isValidObjectId } from "mongoose";

// ‚úÖ Create new store 
export const createStore = async (req: Request, res: Response) => {
    try {
        const { name, icon, banner, description, link, active, order, category } = req.body;

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©
        if (!name?.trim() || !category) {
            return res.status(400).json({
                success: false,
                message: "Store name and category are required",
            });
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© category ID
        if (!isValidObjectId(category)) {
            return res.status(400).json({
                success: false,
                message: "Invalid category ID format",
            });
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÅÿ¶ÿ©
        const categoryExists = await Category.findById(category);
        if (!categoryExists) {
            return res.status(404).json({
                success: false,
                message: "Category not found",
            });
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿπÿØŸÖ ÿ™ŸÉÿ±ÿßÿ± ÿßŸÑÿßÿ≥ŸÖ ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑŸÅÿ¶ÿ©
        const existingStore = await Store.findOne({
            name: name.trim(),
            category
        });
        if (existingStore) {
            return res.status(409).json({
                success: false,
                message: "Store with this name already exists in this category",
            });
        }

        // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖÿ™ÿ¨ÿ± ÿßŸÑÿ¨ÿØŸäÿØ
        const newStore = new Store({
            name: name.trim(),
            icon: icon?.trim() || null,
            banner: banner?.trim() || null,
            description: description?.trim() || '',
            link: link?.trim() || null,
            active: active ?? true,
            order: order || 0,
            category,
        });

        const savedStore = await newStore.save();

        // ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ™ÿ¨ÿ± ŸÖÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ™ÿ®ÿ∑ÿ©
        const populatedStore = await Store.findById(savedStore._id)
            .populate('category', 'name description')

        return res.status(201).json({
            success: true,
            message: "Store created successfully",
            data: populatedStore,
        });
    } catch (error) {
        console.error("createStore error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

// ‚úÖ Update store 
export const updateStore = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { name, icon, banner, description, link, active, order, category } = req.body;


        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© category ID ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ™ŸàŸÅŸäÿ±Ÿá
        if (category && !isValidObjectId(category)) {
            return res.status(400).json({
                success: false,
                message: "Invalid category ID format",
            });
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖÿ™ÿ¨ÿ±
        const existingStore = await Store.findById(id);
        if (!existingStore) {
            return res.status(404).json({
                success: false,
                message: "Store not found",
            });
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÅÿ¶ÿ© ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´Ÿáÿß
        if (category && category !== existingStore.category.toString()) {
            const categoryExists = await Category.findById(category);
            if (!categoryExists) {
                return res.status(404).json({
                    success: false,
                    message: "Category not found",
                });
            }
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿπÿØŸÖ ÿ™ŸÉÿ±ÿßÿ± ÿßŸÑÿßÿ≥ŸÖ
        if (name && name.trim() !== existingStore.name) {
            const duplicateStore = await Store.findOne({
                name: name.trim(),
                category: category || existingStore.category,
                _id: { $ne: id }
            });
            if (duplicateStore) {
                return res.status(409).json({
                    success: false,
                    message: "Store with this name already exists in this category",
                });
            }
        }

        // ÿ®ŸÜÿßÿ° ŸÉÿßÿ¶ŸÜ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´
        const updateData: any = {};
        if (name !== undefined) updateData.name = name.trim();
        if (icon !== undefined) updateData.icon = icon?.trim() || null;
        if (banner !== undefined) updateData.banner = banner?.trim() || null;
        if (description !== undefined) updateData.description = description?.trim() || '';
        if (link !== undefined) updateData.link = link?.trim() || null;
        if (active !== undefined) updateData.active = active;
        if (order !== undefined) updateData.order = order;
        if (category !== undefined) updateData.category = category;

        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ™ÿ¨ÿ±
        const updatedStore = await Store.findByIdAndUpdate(
            id,
            updateData,
            {
                new: true,
                runValidators: true,
            }
        ).populate('category', 'name description')

        return res.status(200).json({
            success: true,
            message: "Store updated successfully",
            data: updatedStore,
        });
    } catch (error) {
        console.error("updateStore error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

// ‚úÖ Delete store
export const deleteStore = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { name } = req.body;


        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        const store = await Store.findById(id)
            .populate('category', 'name')

        if (!store) {
            return res.status(404).json({
                success: false,
                message: "Store not found",
            });
        }

        if (!name?.trim() || name.trim() !== store.name) {
            return res.status(400).json({
                success: false,
                message: "Store name does not match. Please provide the exact name to confirm deletion.",
            });
        }

        await Store.findByIdAndDelete(id);

        return res.status(200).json({
            success: true,
            message: "Store deleted successfully",
            data: {
                deletedStore: store,
            },
        });
    } catch (error) {
        console.error("deleteStore error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

// ‚úÖ Deactivate store
export const deactivateStore = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        const existingStore = await Store.findById(id);
        if (!existingStore) {
            return res.status(404).json({
                success: false,
                message: "Store not found",
            });
        }

        const updatedStore = await Store.findByIdAndUpdate(
            id,
            { active: false },
            { new: true, runValidators: true }
        ).populate('category', 'name')

        return res.status(200).json({
            success: true,
            message: "Store deactivated successfully",
            data: updatedStore,
        });
    } catch (error) {
        console.error("deactivateStore error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

// ‚úÖ Activate store
export const activateStore = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        const existingStore = await Store.findById(id);
        if (!existingStore) {
            return res.status(404).json({
                success: false,
                message: "Store not found",
            });
        }

        const updatedStore = await Store.findByIdAndUpdate(
            id,
            { active: true },
            { new: true, runValidators: true }
        ).populate('category', 'name')

        return res.status(200).json({
            success: true,
            message: "Store activated successfully",
            data: updatedStore,
        });
    } catch (error) {
        console.error("activateStore error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}=== src/controllers/admin/coupon.controller.ts ===
import type { Request, Response } from "express";
import { Coupon } from "../../models/Coupon.model.js";
import { isValidObjectId } from "mongoose";
import { Store } from "../../models/Store.model.js";

export const createCoupon = async (req: Request, res: Response) => {
    try {
        const { code, discount, description, expiryDate, active, store } = req.body;

        if (!code || !code.trim() || discount === undefined || !store) {
            return res.status(400).json({
                success: false,
                message: "Coupon code and name and store and discount are required",
            });
        }

        if (!isValidObjectId(store)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        const existentStore = await Store.findById(store);
        if (!existentStore) {
            return res.status(404).json({
                success: false,
                message: "Store not found",
            });
        }

        if (typeof discount !== "number" || discount < 0 || discount > 100) {
            return res.status(400).json({
                success: false,
                message: "Discount must be a number between 0 and 100",
            });
        }

        const newCoupon = new Coupon({
            code: code.trim(),
            discount: discount,
            description: description?.trim() || '',
            expiryDate: expiryDate,
            active: active ?? true,
            store: store
        });

        const savedCoupon = await newCoupon.save();

        return res.status(201).json({
            success: true,
            message: "Coupon created successfully",
            data: savedCoupon,
        });
    } catch (error) {
        console.error("createCoupon error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

export const updateCoupon = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { code, discount, description, expiryDate, active, store } = req.body;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        if (store && !isValidObjectId(store)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        if (store) {
            const existingStore = await Store.findById(store);
            if (!existingStore) {
                return res.status(404).json({
                    success: false,
                    message: "Store not found",
                });
            }
        }

        if (discount !== undefined) {
            if (typeof discount !== "number" || discount < 0 || discount > 100) {
                return res.status(400).json({
                    success: false,
                    message: "Discount must be a number between 0 and 100",
                });
            }
        }

        const coupon = await Coupon.findById(id);
        if (!coupon) {
            return res.status(404).json({
                success: false,
                message: "Coupon not found",
            });
        }

        if (code) coupon.code = code.trim();
        if (discount !== undefined) coupon.discount = discount;
        if (description !== undefined) coupon.description = description.trim();
        if (expiryDate) coupon.expiryDate = expiryDate;
        if (active !== undefined) coupon.active = active;
        if (store) coupon.store = store;

        await coupon.save();

        return res.status(200).json({
            success: true,
            message: "Coupon updated successfully",
            data: coupon,
        });

    } catch (error) {
        console.error("updateCoupon error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

export const deleteCoupon = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid coupon ID format",
            });
        }

        const coupon = await Coupon.findById(id);
        if (!coupon) {
            return res.status(404).json({
                success: false,
                message: "Coupon not found",
            });
        }

        await Coupon.findByIdAndDelete(id);

        return res.status(200).json({
            success: true,
            message: "Coupon deleted successfully",
            data: coupon,
        });

    } catch (error) {
        console.error("deleteCoupon error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
};
=== src/controllers/admin/category.controller.ts ===
import type { Request, Response } from "express";
import { Category } from "../../models/Category.model.js";
import { isValidObjectId } from "mongoose";


// ‚úÖ Create new category 
export const createCategory = async (req: Request, res: Response) => {
    try {
        const { name, active, order } = req.body;

        const exists = await Category.findOne({ name });
        if (exists) {
            return res.status(400).json({ success: false, message: "Category with this name already exists" });
        }

        const category = new Category({ name, active, order });
        await category.save();

        return res.status(201).json({
            success: true,
            message: "Category created successfully",
            data: category,
        });
    } catch (error) {
        return res.status(500).json({ success: false, message: "Server error", error });
    }
};

// ‚úÖ Update category 
export const updateCategory = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid category ID format",
            });
        }

        // ÿßŸÑÿ≥ŸÖÿßÿ≠ ŸÅŸÇÿ∑ ÿ®ÿ™ÿ≠ÿØŸäÿ´ Ÿáÿ∞Ÿá ÿßŸÑÿ≠ŸÇŸàŸÑ
        const allowedUpdates = ["name", "active", "order"];
        const updateData: any = {};
        for (const key of allowedUpdates) {
            if (req.body[key] !== undefined) {
                updateData[key] = req.body[key];
            }
        }

        const category = await Category.findByIdAndUpdate(id, updateData, {
            new: true,
            runValidators: true,
        });

        if (!category) {
            return res.status(404).json({ success: false, message: "Category not found" });
        }

        return res.status(200).json({
            success: true,
            message: "Category updated successfully",
            data: category,
        });
    } catch (error) {
        return res.status(500).json({ success: false, message: "Server error", error });
    }
};

// ‚úÖ Delete category 
export const deleteCategory = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        const { name } = req.body;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid category ID format",
            });
        }

        const category = await Category.findById(id);
        if (!category) {
            return res.status(404).json({ success: false, message: "Category not found" });
        }

        // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ≥ŸÖ
        if (!name?.trim() || name.trim() !== category.name) {
            return res.status(400).json({
                success: false,
                message: "Category name does not match. Please provide the exact name to confirm deletion.",
            });
        }

        await category.deleteOne(); // ÿ£Ÿà findByIdAndDelete(id);

        return res.status(200).json({
            success: true,
            message: "Category deleted successfully",
            data: category,
        });
    } catch (error) {
        return res.status(500).json({ success: false, message: "Server error", error });
    }
};

=== src/controllers/admin/banner.controller.ts ===
import type { Request, Response } from "express";
import { Banner } from "../../models/Banner.model.js";
import { isValidObjectId } from "mongoose";

interface BannerType {
    name: string;
    image: string;
    link?: string;
    active: boolean;
    order: number;
    createdAt: Date;
    updatedAt: Date;
}

interface UpdateBannerBody {
    name?: string;
    image?: string;
    link?: string;
    active?: boolean;
    order?: number;
}


export const createBanner = async (req: Request<{}, {}, BannerType>, res: Response) => {
    try {
        const { name, image } = req.body;

        if (!req.body || !req.body.name || !req.body.image) {

            return res.status(400).json({
                success: false,
                message: "name and image url is required",
            });
        }

        if (image && !isValidUrl(image)) {
            return res.status(400).json({
                success: false,
                message: "Please provide a valid image URL",
            });
        }

        const existingBanner = await Banner.findOne({ name: name.trim() });
        if (existingBanner) {
            return res.status(400).json({
                success: false,
                message: "Banner with this name already exists",
            });
        }

        const banner = new Banner({ name, image });
        const savedBanner = await banner.save();

        return res.status(201).json({
            success: true,
            message: "A new banner created successfully",
            data: savedBanner,
        });

    } catch (error) {
        console.error("createBanner error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

export const updateBanner = async (req: Request<{ id: string }, {}, UpdateBannerBody>, res: Response) => {
    try {
        const { id } = req.params;
        const updateData = req.body;

        if (!isValidObjectId(id)) {
            return res.status(400).json({ success: false, message: "Invalid ID format" });
        }

        if (updateData.name) updateData.name = updateData.name.trim();
        if (updateData.image) updateData.image = updateData.image.trim();
        if (updateData.link) updateData.link = updateData.link.trim();

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑŸÄ URL ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿµŸàÿ±ÿ©
        if (updateData.image && !isValidUrl(updateData.image)) {
            return res.status(400).json({
                success: false,
                message: "Please provide a valid image URL",
            });
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿπÿØŸÖ ÿ™ŸÉÿ±ÿßÿ± ÿßŸÑÿßÿ≥ŸÖ (ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ±Ÿá)
        if (updateData.name) {
            const existingBanner = await Banner.findOne({
                name: updateData.name,
                _id: { $ne: id }
            });
            if (existingBanner) {
                return res.status(400).json({
                    success: false,
                    message: "Banner with this name already exists",
                });
            }
        }

        const updatedBanner = await Banner.findByIdAndUpdate(id, updateData, { new: true });

        if (!updatedBanner) {
            return res.status(404).json({ success: false, message: "Banner not found" });
        }

        return res.status(200).json({
            success: true,
            message: "Banner updated successfully",
            data: updatedBanner,
        });
    } catch (error) {
        console.error("updateBanner error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
};

export const deleteBanner = async (req: Request<{ id: string }>, res: Response) => {
    try {
        const { id } = req.params;
        if (!isValidObjectId(id)) {
            return res.status(400).json({ success: false, message: "Invalid ID format" });
        }

        const banner = await Banner.findByIdAndDelete(id)

        if (!banner) {
            return res.status(404).json({
                success: false,
                message: "Banner not found",
            });
        }

        return res.status(200).json({
            success: true,
            message: "Banner deleted successfully",
            data: banner,
        });
    } catch (error) {
        console.error("deleteBanner error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

// Helper function ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑŸÄ URL
function isValidUrl(string: string): boolean {
    try {
        new URL(string);
        return true;
    } catch (_) {
        return false;
    }
}=== src/controllers/user/store.controller.ts ===
import type { Request, Response } from "express";
import { isValidObjectId } from "mongoose";
import { User } from "../../models/User.model.js";
import { Store } from "../../models/Store.model.js";

export const getUserFavourites = async (req: Request, res: Response) => {
    try {
        const userId = req.user?.googleId;

        if (!userId) {
            return res.status(401).json({
                success: false,
                message: "Unauthorized",
            });
        }

        const user = await User.findOne({ googleId: userId })
            .populate({
                path: 'favourites',
                populate: [
                    { path: 'category', select: 'name' },
                    { path: 'coupons' }
                ],
                match: { active: true }
            })
            .lean();

        if (!user) {
            return res.status(404).json({
                success: false,
                message: "User not found",
            });
        }

        return res.status(200).json({
            success: true,
            message: "Favourites retrieved successfully",
            data: user.favourites || [],
            count: user.favourites?.length || 0
        });
    } catch (error) {
        console.error("getUserFavourites error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
        });
    }
};

export const addToFavourites = async (req: Request, res: Response) => {
    try {
        const { storeId } = req.body;
        const userId = req.user?.googleId;

        if (!userId) {
            return res.status(401).json({
                success: false,
                message: "Unauthorized",
            });
        }

        if (!storeId || !isValidObjectId(storeId)) {
            return res.status(400).json({
                success: false,
                message: "Valid store ID is required",
            });
        }

        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖÿ™ÿ¨ÿ± Ÿàÿ£ŸÜŸá ŸÜÿ¥ÿ∑
        const store = await Store.findOne({ _id: storeId, active: true });
        if (!store) {
            return res.status(404).json({
                success: false,
                message: "Store not found or inactive",
            });
        }

        const user = await User.findOne({ googleId: userId });
        if (!user) {
            return res.status(404).json({
                success: false,
                message: "User not found",
            });
        }

        if (user.favourites.includes(storeId)) {
            return res.status(400).json({
                success: false,
                message: "Store already in favourites",
            });
        }

        user.favourites.push(storeId);
        await user.save();

        const updatedUser = await User.findOne({ googleId: userId })
            .populate('favourites')
            .lean();

        return res.status(200).json({
            success: true,
            message: "Store added to favourites successfully",
            data: {
                favourites: updatedUser?.favourites || []
            }
        });
    } catch (error) {
        console.error("addToFavourites error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
        });
    }
};

export const removeFromFavourites = async (req: Request, res: Response) => {
    try {
        const { storeId } = req.params;
        const userId = req.user?.googleId;

        if (!userId) {
            return res.status(401).json({
                success: false,
                message: "Unauthorized",
            });
        }

        if (!isValidObjectId(storeId)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        const user = await User.findOne({ googleId: userId });
        if (!user) {
            return res.status(404).json({
                success: false,
                message: "User not found",
            });
        }

        const index = user.favourites.indexOf(storeId as any);
        if (index === -1) {
            return res.status(404).json({
                success: false,
                message: "Store not found in favourites",
            });
        }

        user.favourites.splice(index, 1);
        await user.save();

        const updatedUser = await User.findOne({ googleId: userId })
            .populate('favourites')
            .lean();

        return res.status(200).json({
            success: true,
            message: "Store removed from favourites successfully",
            data: {
                favourites: updatedUser?.favourites || []
            }
        });
    } catch (error) {
        console.error("removeFromFavourites error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
        });
    }
};
=== src/controllers/public/store.controller.ts ===
import type { Request, Response } from "express";
import { Store } from "../../models/Store.model.js";
import { isValidObjectId } from "mongoose";

// ‚úÖ Get all stores
export const getStores = async (req: Request, res: Response) => {
    try {
        const page = parseInt((req.query.page as string) || "1");
        const limit = 20;
        const skipped = (page - 1) * limit;

        const { active, category, name } = req.query;
        const filter: any = {};

        if (active !== undefined) {
            filter.active = active === 'true';
        }

        if (category) {
            if (!isValidObjectId(category)) {
                return res.status(400).json({
                    success: false,
                    message: "Invalid category ID format",
                });
            }
            filter.category = category;
        }

        if (name) {
            // filter.$or = [
            //     { name_ar: { $regex: name as string, $options: 'i' } },
            //     { name_en: { $regex: name as string, $options: 'i' } },
            // ];
            filter.name = { $regex: name as string, $options: 'i' };

        }

        const totalCount = await Store.countDocuments(filter);
        const remaining = Math.max(totalCount - skipped - limit, 0);

        const stores = await Store.find(filter)
            .populate('category', 'name')
            .populate('coupons')
            .skip((page - 1) * limit)
            .limit(limit)
            .sort({ order: 1, createdAt: -1 })

        res.status(200).json({
            success: true,
            message: stores.length > 0 ? "Stores retrieved successfully" : "No stores found",
            data: stores,
            pageCount: stores.length,
            totalCount,
            remaining
        });
    } catch (error) {
        console.error("getStores error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}

export const getStoreById = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        const store = await Store.findById(id)
            .populate('category', 'name')

        if (!store) {
            return res.status(404).json({
                success: false,
                message: "Store not found",
            });
        }

        return res.status(200).json({
            success: true,
            message: "Store retrieved successfully",
            data: store,
        });
    } catch (error) {
        console.error("getStoreById error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}=== src/controllers/public/coupon.controller.ts ===
import type { Request, Response } from "express";
import { Coupon } from "../../models/Coupon.model.js";
import { isValidObjectId } from "mongoose";

export const getCoupons = async (req: Request, res: Response) => {
    try {
        const { store, active } = req.query;
        const filter: any = {};

        if (store) {
            if (isValidObjectId(store)) {
                filter.store = store;
            } else {
                return res.status(200).json({
                    success: true,
                    message: "No Coupons found",
                    data: [],
                    count: 0
                });
            }
        }

        if (active !== undefined) filter.active = active === "true";

        const coupons = await Coupon.find(filter).sort({ usedCount: -1 });

        return res.status(200).json({
            success: true,
            message: coupons.length > 0 ? "Coupons retrieved successfully" : "No Coupons found",
            data: coupons,
            count: coupons.length
        });
    } catch (error) {
        console.error("getCoupons error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
}
=== src/controllers/public/category.controller.ts ===
import type { Request, Response } from "express";
import { Category } from "../../models/Category.model.js";
import { isValidObjectId } from "mongoose";


// ‚úÖ Get all categories 
export const getCategories = async (req: Request, res: Response) => {
    try {
        const categories = await Category.find().sort({ order: 1 });
        return res.status(200).json({
            success: true,
            message: "Categories retrieved successfully",
            count: categories.length,
            data: categories,
        });
    } catch (error) {
        return res.status(500).json({ success: false, message: "Server error", error });
    }
};

// ‚úÖ Get single category 
export const getCategoryById = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid store ID format",
            });
        }

        const category = await Category.findById(id);
        if (!category) {
            return res.status(404).json({ success: false, message: "Category not found" });
        }

        return res.status(200).json({
            success: true,
            message: "Category retrieved successfully",
            data: category,
        });
    } catch (error) {
        return res.status(500).json({ success: false, message: "Server error", error });
    }
};=== src/controllers/public/banner.controller.ts ===
import type { Request, Response } from "express";
import { Banner } from "../../models/Banner.model.js";
import { isValidObjectId } from "mongoose";

export const getBanners = async (req: Request, res: Response) => {
    try {
        const banners = await Banner.find().sort({ order: 1, createdAt: -1 });

        return res.status(200).json({
            success: true,
            message: "Banners retrieved successfully",
            data: banners,
        });
    } catch (error) {
        console.error("getBanners error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }

};

export const getBannerById = async (req: Request<{ id: string }>, res: Response) => {
    try {
        const { id } = req.params;

        if (!isValidObjectId(id)) {
            return res.status(400).json({
                success: false,
                message: "Invalid banner ID format",
            });
        }

        const banner = await Banner.findById(id);

        if (!banner) {
            return res.status(404).json({
                success: false,
                message: "Banner not found",
            });
        }

        return res.status(200).json({
            success: true,
            message: "Banner retrieved successfully",
            data: banner,
        });
    } catch (error) {
        console.error("getBannerById error:", error);
        return res.status(500).json({
            success: false,
            message: "Server error",
            error: process.env.NODE_ENV === "development" ? error : undefined,
        });
    }
};=== src/server.ts ===
import dotenv from 'dotenv';
if (process.env.NODE_ENV === 'test') {
    dotenv.config({ quiet: true });
} else {
    dotenv.config();
}

import express from 'express';
import type { Request, Response, NextFunction } from 'express';
import { apiRateLimiter } from "./middleware/rateLimiter.js";
import cors from 'cors';
import helmet from 'helmet';
import { connectDB } from './database/connection.js';

// üîµ Auth Routes
import authRoutes from "./routes/auth.routes.js"

// üî¥ Admin Routes (Dashboard)
import adminBannerRoutes from "./routes/admin/banner.routes.js";
import adminCategoryRoutes from "./routes/admin/category.routes.js";
import adminStoreRoutes from "./routes/admin/store.routes.js";
import adminCouponRoutes from "./routes/admin/coupon.routes.js";

// üåê Public Routes (General Access)
import bannerRoutes from "./routes/public/banner.routes.js"
import categoryRoutes from "./routes/public/category.routes.js"
import storeRoutes from "./routes/public/store.routes.js"
import couponRoutes from "./routes/public/coupon.routes.js"

// üü¢ User Routes (Protected)
import userStoreRoutes from "./routes/user/store.routes.js"


// VARIABLES
const port = process.env.PORT || 3000;
const app = express();

// Security & Middleware
app.use(express.json());
app.use(helmet({}));
app.use(cors());
app.use("/", apiRateLimiter);

// Routes
app.get('/', (req: Request, res: Response) => {
    res.send('Hello Express + TypeScript');
});

app.get('/error-test', (req: Request, res: Response) => {
    throw new Error('Forced error');
});

// üîµ Auth Routes
app.use("/auth", authRoutes);

// üî¥ Admin Routes (Dashboard)
app.use("/admin/banner", adminBannerRoutes);
app.use("/admin/category", adminCategoryRoutes);
app.use("/admin/store", adminStoreRoutes);
app.use("/admin/coupon", adminCouponRoutes);

// üåê Public Routes (General Access)
app.use("/banner", bannerRoutes);
app.use("/category", categoryRoutes);
app.use("/store", storeRoutes);
app.use("/coupon", couponRoutes);

// üü¢ User Routes (Protected)
app.use("/user/store", userStoreRoutes);

// Error handling middleware 
app.use((err: any, req: Request, res: Response, next: NextFunction) => {
    if (err instanceof SyntaxError && "body" in err) {
        return res.status(400).json({
            success: false,
            message: "Invalid JSON in request body",
        });
    }

    console.error("üî• Unexpected error:", err);
    res.status(500).json({
        success: false,
        message: "Internal server error",
    });
});

export { app };

if (process.env.NODE_ENV != "test") {
    connectDB()
        .then(() => {
            app.listen(port, () => {
                console.log(`üü¢ Server running on http://localhost:${port}`);
            });
        }).catch(err => {
            console.error("DB connection failed:", err);
            process.exit(1);
        });
}=== src/routes/admin/store.routes.ts ===
import express from "express";
import { activateStore, createStore, deactivateStore, deleteStore, updateStore } from "../../controllers/admin/store.controller.js";
const router = express.Router();

router.post("/", createStore)

router.put("/:id", updateStore)
router.put("/:id/deactivate", deactivateStore)
router.put("/:id/activate", activateStore)

router.delete("/:id", deleteStore)


export default router;=== src/routes/admin/category.routes.ts ===
import express from "express";
import { createCategory, deleteCategory, updateCategory } from "../../controllers/admin/category.controller.js";

const router = express.Router();

router.post("/", createCategory)

router.put("/:id", updateCategory)

router.delete("/:id", deleteCategory)

export default router;=== src/routes/admin/banner.routes.ts ===
import express from 'express';
import { createBanner, deleteBanner, updateBanner } from '../../controllers/admin/banner.controller.js';
const router = express.Router();


router.post('/', createBanner);
router.put('/:id', updateBanner);
router.delete('/:id', deleteBanner);

export default router; === src/routes/admin/coupon.routes.ts ===
import express from "express"
import { createCoupon, deleteCoupon, updateCoupon } from "../../controllers/admin/coupon.controller.js";
const router = express.Router();

router.post("/", createCoupon);
router.put("/:id", updateCoupon);
router.delete("/:id", deleteCoupon);

export default router=== src/routes/user/store.routes.ts ===
import express from "express";
import { authMiddleware } from "../../middleware/auth.js";
import { getUserFavourites, addToFavourites, removeFromFavourites } from "../../controllers/user/store.controller.js";
const router = express.Router();
router.use(authMiddleware);

router.get("/favourites/my", getUserFavourites);
router.post("/favourites", addToFavourites);
router.delete("/favourites/:storeId", removeFromFavourites);

export default router;=== src/routes/public/store.routes.ts ===
import express from "express";
import { getStoreById, getStores } from "../../controllers/public/store.controller.js";
const router = express.Router();

router.get("/", getStores)
router.get("/:id", getStoreById)

export default router;=== src/routes/public/category.routes.ts ===
import express from "express";
import { getCategories, getCategoryById } from "../../controllers/public/category.controller.js";

const router = express.Router();

router.get("/", getCategories)

router.get("/:id", getCategoryById)

export default router;=== src/routes/public/banner.routes.ts ===
import express from 'express';
import { getBannerById, getBanners } from '../../controllers/public/banner.controller.js';
const router = express.Router();

router.get('/', getBanners);
router.get('/:id', getBannerById);

export default router; === src/routes/public/coupon.routes.ts ===
import express from "express"
import { getCoupons } from "../../controllers/public/coupon.controller.js";
const router = express.Router();

router.get("/", getCoupons);

export default router=== src/routes/auth.routes.ts ===
import express from 'express';
import { googleLogin, verifyToken } from '../controllers/auth.controller.js';
import { authMiddleware } from "../middleware/auth.js"
import { authRateLimiter } from "../middleware/rateLimiter.js";

const router = express.Router();

router.post('/google/token', authRateLimiter, googleLogin);
router.post('/verifyToken', authMiddleware, verifyToken);

export default router;
=== src/services/googleService.ts ===
import { OAuth2Client, type TokenPayload } from 'google-auth-library';
import dotenv from 'dotenv';
dotenv.config();

const client = new OAuth2Client();

export async function verifyGoogleToken(idToken: string): Promise<TokenPayload | undefined> {
    const ticket = await client.verifyIdToken({
        idToken,
        audience: [process.env.GOOGLE_CLIENT_ID].toString()

    });
    return ticket.getPayload() || undefined;
}


